import {
  Alliance,
  AllianceNomination,
  Answer,
  AnswerValue,
  AnyEntityVariantData,
  AnyNominationVariantData,
  AnyNominationVariantPublicData,
  type AnyQuestionVariant,
  type AnyQuestionVariantData,
  ArrayAnswerFormatterOptions,
  Candidate,
  CandidateNomination,
  type Collection,
  Constituency,
  type ConstituencyData,
  ConstituencyGroup,
  type ConstituencyGroupData,
  createDeterministicId,
  createQuestion,
  DataNotFoundError,
  DataProvisionError,
  DataTypeError,
  DynamicObjectType,
  Election,
  type ElectionData,
  ENTITY_TYPE,
  type EntityType,
  type EntityVariant,
  EntityVariantTree,
  Faction,
  FactionNomination,
  type FilterTargets,
  formatAllianceName,
  formatAllianceShortName,
  formatBooleanAnswer,
  formatDateAnswer,
  formatImageAnswer,
  formatInitials,
  formatMissingAnswer,
  formatMultipleTextAnswer,
  formatName,
  formatNumberAnswer,
  formatTextAnswer,
  FullVaaData,
  type Id,
  IdentityProps,
  type Image,
  isValidId,
  type MappedCollection,
  MultipleChoiceQuestion,
  Nomination,
  NominationVariant,
  NominationVariantTree,
  order,
  Organization,
  OrganizationNomination,
  parseEntityTree,
  parseNominationTree,
  QUESTION_TYPE,
  QuestionCategory,
  type QuestionCategoryData,
  QuestionCategoryType,
  QuestionType,
  QuestionVariant,
  RootCollections,
  RootFormatters,
  SingleChoiceQuestion,
  Updatable
} from '../internal';

/*
 * The root for all of the `DataObject`s. Each such must belong to a `DataRoot`.
 */
export class DataRoot extends Updatable {
  /**
   * These can be set to change the way data is formatted by accessors. In the case object properties, if the object data already contains the target property, it will take precedence over that generated by a formatter.
   */
  protected formatters: RootFormatters = {
    /** Generate an `Alliance`’s `name` from it’s member `Organization`s. */
    allianceName: formatAllianceName,
    /** Generate an `Alliance`’s `shortName` from it’s member `Organization`s. */
    allianceShortName: formatAllianceShortName,
    /** Format a `Candidate`'s full `name`. Override this to, e.g., combine the first and last name in a different order. */
    candidateName: formatName,
    /** Format `Candidate` initials for a `shortName` */
    candidateShortName: formatInitials,
    /** Generate a `Faction`’s name */
    factionName: () => '—',
    /** Format the `Answer.value` if it's a `boolean`. */
    booleanAnswer: formatBooleanAnswer,
    /** Format the `Answer.value` if it's a `Date`. */
    dateAnswer: formatDateAnswer,
    /** Format the `Answer.value` if it's an `Image`. */
    imageAnswer: formatImageAnswer,
    /** Format the `Answer.value` if it's a missing answer. */
    missingAnswer: formatMissingAnswer,
    /** Format the `Answer.value` if it's a `string` array. */
    multipleTextAnswer: formatMultipleTextAnswer,
    /** Format the `Answer.value` if it's a `number`. */
    numberAnswer: formatNumberAnswer,
    /** Format the `Answer.value` if it's a `string`. */
    textAnswer: formatTextAnswer
  };
  /**
   * The locale to use for formatting.
   */
  locale?: string;
  /**
   * A prefix used when creating unique `Id`s automatically. `Id`s passed in object data cannot contaih this string. If the data source uses it in ids, change the prexix before providing data.
   */
  autoIdPrefix = '__';

  protected children: {
    [KName in keyof RootCollections]?: MappedCollection<RootCollections[KName]>;
  } = {};

  /**
   * Create and possibly init the `DataRoot` instance.
   * @param data - Optional full VAA data for the `DataRoot`, with which it will be initialized.
   * @param locale - Optional locale to use with the `format` functions.
   */
  constructor({
    data,
    locale
  }: {
    data?: FullVaaData;
    locale?: string;
  } = {}) {
    super();
    if (data) this.provideFullData(data);
    this.locale = locale;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Collection getters
  //////////////////////////////////////////////////////////////////////////////

  get alliances(): Collection<Alliance> {
    return this.getCollectionAsArray('alliances');
  }

  get allianceNominations(): Collection<AllianceNomination> {
    return this.getCollectionAsArray('allianceNominations');
  }

  get candidates(): Collection<Candidate> {
    return this.getCollectionAsArray('candidates');
  }

  get candidateNominations(): Collection<CandidateNomination> {
    return this.getCollectionAsArray('candidateNominations');
  }

  get constituencies(): Collection<Constituency> {
    return this.getCollectionAsArray('constituencies');
  }

  get constituencyGroups(): Collection<ConstituencyGroup> {
    return this.getCollectionAsArray('constituencyGroups');
  }

  get elections(): Collection<Election> {
    return this.getCollectionAsArray('elections');
  }

  get factions(): Collection<Faction> {
    return this.getCollectionAsArray('factions');
  }

  get factionNominations(): Collection<FactionNomination> {
    return this.getCollectionAsArray('factionNominations');
  }

  get organizations(): Collection<Organization> {
    return this.getCollectionAsArray('organizations');
  }

  get organizationNominations(): Collection<OrganizationNomination> {
    return this.getCollectionAsArray('organizationNominations');
  }

  get questions(): Collection<AnyQuestionVariant> {
    return this.getCollectionAsArray('questions');
  }

  get questionCategories(): Collection<QuestionCategory> {
    return this.getCollectionAsArray('questionCategories');
  }

  /**
   * A utility method for getting a collection by type and converting it to a `Collection`.
   * @param name - The name of the collection
   * @returns The collection as an ordered `Collection`, or `undefined` if the collection has not yet been provided.
   */
  protected getCollectionAsArray<
    TCollection extends keyof RootCollections,
    TArray = Array<NonNullable<RootCollections[TCollection]>>
  >(name: TCollection): TArray {
    return (this.children[name] ? [...this.children[name]!.values()].sort(order) : []) as TArray;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Generic type-and-id-based object getters
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Get a speficic `EntityVariant` by type and id.
   * @param type - The type of the entity
   * @param id - The id of the entity
   * @returns The `EntityVariant` with the given id
   * @throws If the object is not found.
   */
  getEntity<TType extends EntityType>(type: TType, id: Id): EntityVariant[TType] {
    return this.getChild(this.getEntityCollectionName(type), id);
  }

  /**
   * Returns the name of the entity collection for the given entity type.
   */
  protected getEntityCollectionName(type: EntityType): keyof RootCollections {
    switch (type) {
      case ENTITY_TYPE.Alliance:
        return 'alliances';
      case ENTITY_TYPE.Candidate:
        return 'candidates';
      case ENTITY_TYPE.Faction:
        return 'factions';
      case ENTITY_TYPE.Organization:
        return 'organizations';
      default:
        throw new DataTypeError(`Unknown entity type: ${type}`);
    }
  }

  /**
   * Get a speficic `NominationVariant` by type and id.
   * @param type - The type of the entity
   * @param id - The id of the nomination
   * @returns The `NominationVariant` with the given id
   * @throws If the object is not found.
   */
  getNomination<TType extends EntityType>(type: TType, id: Id): NominationVariant[TType] {
    return this.getChild(this.getNominationCollectionName(type), id);
  }

  /**
   * Returns the name of the nomination collection for the given entity type.
   */
  protected getNominationCollectionName(type: EntityType): keyof RootCollections {
    switch (type) {
      case ENTITY_TYPE.Alliance:
        return 'allianceNominations';
      case ENTITY_TYPE.Candidate:
        return 'candidateNominations';
      case ENTITY_TYPE.Faction:
        return 'factionNominations';
      case ENTITY_TYPE.Organization:
        return 'organizationNominations';
      default:
        throw new DataTypeError(`Unknown entity type: ${type}`);
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  // Specifif id-based object getters
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Get a speficic `Alliance` by id.
   * @param id
   * @returns The `Alliance` with the given id
   * @throws If the object is not found.
   */
  getAlliance(id: Id): Alliance {
    return this.getChild('alliances', id);
  }

  /**
   * Get a speficic `AllianceNomination` by id.
   * @param id
   * @returns The `AllianceNomination` with the given id
   * @throws If the object is not found.
   */
  getAllianceNomination(id: Id): AllianceNomination {
    return this.getChild('allianceNominations', id);
  }

  /**
   * Get a speficic `Candidate` by id.
   * @param id
   * @returns The `Candidate` with the given id
   * @throws If the object is not found.
   */
  getCandidate(id: Id): Candidate {
    return this.getChild('candidates', id);
  }

  /**
   * Get a speficic `CandidateNomination` by id.
   * @param id
   * @returns The `CandidateNomination` with the given id
   * @throws If the object is not found.
   */
  getCandidateNomination(id: Id): CandidateNomination {
    return this.getChild('candidateNominations', id);
  }

  /**
   * Get a speficic `Constituency` by id.
   * @param id
   * @returns The `Constituency` with the given id
   * @throws If the object is not found.
   */
  getConstituency(id: Id): Constituency {
    return this.getChild('constituencies', id);
  }

  /**
   * Get a speficic `ConstituencyGroup` by id.
   * @param id
   * @returns The `ConstituencyGroup` with the given id
   * @throws If the object is not found.
   */
  getConstituencyGroup(id: Id): ConstituencyGroup {
    return this.getChild('constituencyGroups', id);
  }

  /**
   * Get a speficic `Election` by id.
   * @param id
   * @returns The `Election` with the given id
   * @throws If the object is not found.
   */
  getElection(id: Id): Election {
    return this.getChild('elections', id);
  }

  /**
   * Get a speficic `Faction` by id.
   * @param id
   * @returns The `Faction` with the given id
   * @throws If the object is not found.
   */
  getFaction(id: Id): Faction {
    return this.getChild('factions', id);
  }

  /**
   * Get a speficic `FactionNomination` by id.
   * @param id
   * @returns The `FactionNomination` with the given id
   * @throws If the object is not found.
   */
  getFactionNomination(id: Id): FactionNomination {
    return this.getChild('factionNominations', id);
  }

  /**
   * Get a specific `Organization` by id.
   * @param id
   * @returns The `Organization` with the given id
   * @throws If the object is not found.
   */
  getOrganization(id: Id): Organization {
    return this.getChild('organizations', id);
  }

  /**
   * Get a specific `OrganizationNomination` by id.
   * @param id
   * @returns The `OrganizationNomination` with the given id
   * @throws If the object is not found.
   */
  getOrganizationNomination(id: Id): OrganizationNomination {
    return this.getChild('organizationNominations', id);
  }

  /**
   * Get a speficic `Question` by id.
   * @param id
   * @returns The `Question` with the given id
   * @throws If the object is not found.
   */
  getQuestion(id: Id): AnyQuestionVariant {
    return this.getChild('questions', id);
  }

  /**
   * Get a speficic `QuestionCategory` by id.
   * @param id
   * @returns The `QuestionCategory` with the given id
   * @throws If the object is not found.
   */
  getQuestionCategory(id: Id): QuestionCategory {
    return this.getChild('questionCategories', id);
  }

  /**
   * A utility method for getting any child by collection name and id.
   * @param collection - The name of the collection
   * @param id - The id of the object
   * @returns The object in the collection with the given id
   * @throws If the object is not found.
   */
  protected getChild<TCollection extends keyof RootCollections, TChild = NonNullable<RootCollections[TCollection]>>(
    collection: TCollection,
    id: Id
  ): TChild {
    const res = this.children[collection]?.get(`${id}`);
    if (!res) throw new DataNotFoundError(`Child in collection ${collection} with id ${id} not found`);
    return res as TChild;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Other object getters
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Find `Nomination`s based on `entityType`, `entityId`, `electionRound`, `electionId` and `constituencyId`.
   * @param type - The type of the nominated entity.
   * @param id - The id of the nominated entity.
   */
  findNominations<TEntity extends EntityType>({
    entityType,
    entityId,
    electionId,
    electionRound,
    constituencyId
  }: {
    entityType: TEntity;
    entityId?: Id;
    electionId?: Id;
    electionRound?: number;
    constituencyId?: Id;
  }): Array<NominationVariant[TEntity]> {
    const collection = this.children[this.getNominationCollectionName(entityType)] as
      | MappedCollection<NominationVariant[TEntity]>
      | undefined;
    return collection
      ? [...collection.values()].filter(
          (n) =>
            (!entityId || `${n.data.entityId}` === `${entityId}`) &&
            (!electionId || `${n.data.electionId}` === `${electionId}`) &&
            (!electionRound || n.electionRound === electionRound) &&
            (!constituencyId || `${n.data.constituencyId}` === `${constituencyId}`)
        )
      : [];
  }

  /**
   * Get all provided `Nomination`s for a specific `Entity` passing either itself or its `type` and `id`.
   * @param type - The type of the nominated entity.
   * @param id - The id of the nominated entity.
   * @paramn options - Additional options passed to `findNominations`.
   * @returns An array of `Nomination`s for the given `Entity` or `undefined` if `Nomination`s have not yet been provided.
   */
  getNominationsForEntity<TEntity extends EntityType>(
    {
      type,
      id
    }: {
      type: TEntity;
      id: Id;
    },
    options: {
      electionId?: Id;
      electionRound?: number;
      constituencyId?: Id;
    } = {}
  ): Array<NominationVariant[TEntity]> {
    return this.findNominations({ ...options, entityType: type, entityId: id });
  }

  /**
   * Get all provided `Nomination`s of a specific entity type for an `Election`-`Constituency` pair.
   * @param type - The type of the nominated entity.
   * @param electionId - The id of the election.
   * @param electionRound - The possible round of the election.
   * @param constituencyId - The id of the constituency.
   * @returns An array of `Nomination`s for the given `Entity` or `undefined` if `Nomination`s have not yet been provided.
   */
  getNominationsForConstituency<TEntity extends EntityType>({
    type,
    electionId,
    electionRound,
    constituencyId
  }: {
    type: TEntity;
    electionId: Id;
    electionRound?: number;
    constituencyId: Id;
  }): Array<NominationVariant[TEntity]> {
    return this.findNominations({ entityType: type, electionId, electionRound, constituencyId });
  }

  /**
   * Find `AnyQuestionVariant`s based on `FilterTargets` and `QuestionCategoryType`.
   * @param type - The type of the `QuestionCategory`
   * @param filters - Any `FilterTargets`
   */
  findQuestions({ type, ...filters }: FilterTargets & { type?: QuestionCategoryType }): Array<AnyQuestionVariant> {
    const hasFilters = Object.values(filters).filter((f) => f != null).length > 0;
    if (!type && !hasFilters) return this.questions;
    if (type && !hasFilters) return this.getQuestionsByType(type);
    // Apply filters first to categories and then questions
    return this.questionCategories
      ?.filter((qc) => {
        if (type && qc.type !== type) return false;
        return qc.appliesTo(filters);
      })
      .flatMap((qc) => qc.getApplicableQuestions(filters));
  }

  /**
   * Get `AnyQuestionVariant`s of a specific `QuestionCategoryType`.
   * @param type - The type to look for.
   * @returns An array of `AnyQuestionVariant`s or `undefined` if questions haven't been provided yet.
   */
  getQuestionsByType(type: QuestionCategoryType): Array<AnyQuestionVariant> {
    return this.getQuestionCategoriesByType(type).flatMap((qc) => qc.questions);
  }

  /**
   * Get `QuestionCategory`s of a specific `QuestionCategoryType`.
   * @param type - The type to look for.
   * @returns An array of `QuestionCategory`s or `undefined` if questions haven't been provided yet.
   */
  getQuestionCategoriesByType(type: QuestionCategoryType): Array<QuestionCategory> {
    return this.questionCategories?.filter((qc) => qc.type === type);
  }

  //////////////////////////////////////////////////////////////////////////////
  // Data provision
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Provide all data at once. All existing data is reset.
   */
  provideFullData(data: FullVaaData): void {
    const { elections, constituencies, questions, entities, nominations } = data;
    this.update(() => {
      this.provideElectionData(elections);
      this.provideConstituencyData(constituencies);
      this.provideQuestionData(questions);
      this.provideEntityData(entities);
      this.provideNominationData(nominations);
    });
  }

  /**
   * Provide the constituency and group data to the `DataRoot`. Existing data will be reset, along with any {@link DEPENDENT_COLLECTIONS | dependent collections}.
   */
  provideConstituencyData({
    groups,
    constituencies
  }: {
    groups: Array<ConstituencyGroupData>;
    constituencies: Array<ConstituencyData>;
  }) {
    this.update(() => {
      this.provideData('constituencyGroups', groups, (args) => new ConstituencyGroup(args));
      this.provideData('constituencies', constituencies, (args) => new Constituency(args));
    });
  }

  /**
   * Provide election data to the `DataRoot`. Existing data will be reset, along with any {@link DEPENDENT_COLLECTIONS | dependent collections}.
   */
  provideElectionData(data: Readonly<Array<ElectionData>>): void {
    this.provideData('elections', data, (args) => new Election(args));
  }

  /**
   * Provide the data for all entities to the `DataRoot`. Existing data will be reset, along with any {@link DEPENDENT_COLLECTIONS | dependent collections}.
   * @param data - The data for all entities. Two formats are supported: a single array of `AnyEntityVariantData` with the `type` specified for each, or a structured object with these `EntityType`s as keys and the actual data without them.
   * @param options - Additional options for data provision.
   */
  provideEntityData(data: Readonly<Array<AnyEntityVariantData>> | Readonly<EntityVariantTree>): void {
    const dataArray: Readonly<Array<AnyEntityVariantData>> = !Array.isArray(data)
      ? parseEntityTree(data as EntityVariantTree)
      : data;
    this.update(() => {
      this.provideData(
        'candidates',
        dataArray.filter((d) => d.type === ENTITY_TYPE.Candidate),
        (args) => new Candidate(args)
      );
      this.provideData(
        'factions',
        dataArray.filter((d) => d.type === ENTITY_TYPE.Faction),
        (args) => new Faction(args)
      );
      this.provideData(
        'organizations',
        dataArray.filter((d) => d.type === ENTITY_TYPE.Organization),
        (args) => new Organization(args)
      );
      this.provideData(
        'alliances',
        dataArray.filter((d) => d.type === ENTITY_TYPE.Alliance),
        (args) => new Alliance(args)
      );
    });
  }

  /**
   * Provide the data for all nominations to the `DataRoot`. Existing data will be reset, along with any {@link DEPENDENT_COLLECTIONS | dependent collections}.
   * @param data - The data for all nominations. Two formats are supported: a single array of `AnyNominationVariantData` with the `electionId` and `constituencyId` specified for each, or a structured object with these `Id`s as keys and the actual data without them.
   * @param options - Additional options for data provision.
   * @returns The created nominations because they’re needed by some nomination initializers.
   */
  provideNominationData(data: Readonly<Array<AnyNominationVariantPublicData>> | Readonly<NominationVariantTree>): {
    allianceNominations: Array<AllianceNomination>;
    organizationNominations: Array<OrganizationNomination>;
    factionNominations: Array<FactionNomination>;
    candidateNominations: Array<CandidateNomination>;
  } {
    const out: Partial<ReturnType<this['provideNominationData']>> = {};
    const dataArray: Readonly<Array<AnyNominationVariantData>> = !Array.isArray(data)
      ? parseNominationTree(data as NominationVariantTree)
      : data;
    this.update(() => {
      out.candidateNominations = this.provideData(
        'candidateNominations',
        dataArray.filter((d) => d.entityType === ENTITY_TYPE.Candidate),
        (args) => new CandidateNomination(args)
      );
      out.factionNominations = this.provideData(
        'factionNominations',
        dataArray.filter((d) => d.entityType === ENTITY_TYPE.Faction),
        (args) => new FactionNomination(args)
      );
      out.organizationNominations = this.provideData(
        'organizationNominations',
        dataArray.filter((d) => d.entityType === ENTITY_TYPE.Organization),
        (args) => new OrganizationNomination(args)
      );
      out.allianceNominations = this.provideData(
        'allianceNominations',
        dataArray.filter((d) => d.entityType === ENTITY_TYPE.Alliance),
        (args) => new AllianceNomination(args)
      );
    });
    return out as ReturnType<this['provideNominationData']>;
  }

  /**
   * Provide question and question category data to the `DataRoot`. Existing data will be reset, along with any {@link DEPENDENT_COLLECTIONS | dependent collections}.
   */
  provideQuestionData({
    categories,
    questions
  }: {
    categories: Array<QuestionCategoryData>;
    questions: Array<AnyQuestionVariantData>;
  }): void {
    this.update(() => {
      this.provideData('questionCategories', categories, (args) => new QuestionCategory(args));
      this.provideData('questions', questions, createQuestion);
    });
  }

  /**
   * Create a deterministic `Id` for a `Nomination` or an implied `Entity`.
   * @param args - Arguments passed to `createDeterministicId`.
   * @returns A deterministic `Id` for the object.
   */
  createId<TType extends DynamicObjectType>(args: { type: TType; data: IdentityProps[TType] }): Id {
    return createDeterministicId({
      prefix: this.autoIdPrefix,
      ...args
    });
  }

  /**
   * Returns true if `id` is a valid `Id` for this `DataRoot`.
   * @param id - The `Id` to check.
   */
  checkId(id: Id): boolean {
    return isValidId(id) && !id.startsWith(this.autoIdPrefix);
  }

  /**
   * Check that a `DataObject` is valid.
   * TODO: Expand coverage to other data types.
   * @param object - The `DataObject` to check.
   * @returns An error message if the object is invalid.
   */
  checkObject(object: object): void | string {
    if (object instanceof Nomination) {
      try {
        object.entity; // eslint-disable-line @typescript-eslint/no-unused-expressions
      } catch {
        return 'No matching entity found for nomination.';
      }
    }
  }

  /**
   * Provide data to the `DataRoot`. All edits to the `children` collections should be made using this method.
   * @param collection - The name of the collection
   * @param data - The data to be passed to the `constructor`
   * @param constructor - The constructor function for the new objects, which is passed both the `data` items and the `DataRoot` instance.
   * @returns The created objects.
   */
  protected provideData<TCollection extends keyof RootCollections, TData, TChild extends RootCollections[TCollection]>(
    collection: TCollection,
    data: Readonly<Array<TData>>,
    constructor: (params: { data: TData; root: DataRoot }) => TChild
  ): Array<TChild> {
    if (!data.length) return [];
    this.log(`provideData() to ${collection} with ${data.length} new objects`);
    this.children[collection] ??= new Map();
    const objects = new Array<TChild>();
    const collObject = this.children[collection] as MappedCollection<TChild>;
    this.update(() =>
      data.forEach((d) => {
        const obj = constructor({ data: d, root: this });
        // Check that the object is valid before adding it to the collection
        const error = this.checkObject(obj);
        if (error) throw new DataProvisionError(`Object ${obj.id} could not be added to ${collection}: ${error}.`);
        collObject.set(obj.id, obj);
        objects.push(obj);
      })
    );
    return objects;
  }

  //////////////////////////////////////////////////////////////////////////////
  // Output formatting
  //////////////////////////////////////////////////////////////////////////////

  // We have to use this hard-coded method names to get typing right without too much complexity.

  /**
   * Generate an `Alliance`’s `name` from it’s member `Organization`s.
   */
  formatAllianceName(args: Parameters<RootFormatters['allianceName']>[0]): string {
    return this.formatters.allianceName({ locale: this.locale, ...args });
  }

  /**
   * Generate an `Alliance`’s `shortName` from it’s member `Organization`s.
   */
  formatAllianceShortName(args: Parameters<RootFormatters['allianceShortName']>[0]): string {
    return this.formatters.allianceShortName({ locale: this.locale, ...args });
  }

  /**
   * Format a `Candidate`'s full `name`. Override this to, e.g., combine the first and last name in a different order.
   */
  formatCandidateName(args: Parameters<RootFormatters['candidateName']>[0]): string {
    return this.formatters.candidateName({ locale: this.locale, ...args });
  }

  /**
   * Format `Candidate` initials for a `shortName`
   */
  formatCandidateShortName(args: Parameters<RootFormatters['candidateShortName']>[0]): string {
    return this.formatters.candidateShortName({ locale: this.locale, ...args });
  }

  /**
   * Generate a `Faction`’s name
   */
  formatFactionName(args: Parameters<RootFormatters['factionName']>[0]): string {
    return this.formatters.factionName({ locale: this.locale, ...args });
  }

  /**
   * Format any `Answer`, including missing ones, to a question as a string. The formatting is controlled by the formatters defined in the `DataRoot`.
   * @param answer - The possible `Answer`.
   * @param question - The `Question` the answer is for.
   * @param multipleAnswerArgs - Additional arguments for the `multipleTextAnswer` formatter.
   * @returns A string.
   * @throws {DataTypeError} If `Question.type` is not supported.
   */
  formatAnswer<TQuestion extends QuestionType>({
    answer,
    question,
    ...multipleAnswerArgs
  }: {
    answer?: Answer<AnswerValue[TQuestion]> | null;
    question: QuestionVariant[TQuestion];
  } & ArrayAnswerFormatterOptions): string {
    const { locale } = this;
    if (answer == null) return this.formatters.missingAnswer({ locale, question });
    // We use instanceof checks to catch subclasses of choice questions
    if (question instanceof SingleChoiceQuestion)
      // `getAnswer()` ensures that the answer value is not missing and the `Choice` is available
      return this.formatters.textAnswer({
        locale,
        question,
        value: question.getChoice((answer as Answer<Id>).value!)!.label
      });
    if (question instanceof MultipleChoiceQuestion)
      // The array may be empty, but that is left for the `multipleText` formatter to handle
      return this.formatters.multipleTextAnswer({
        locale,
        question,
        value: (answer as Answer<Array<Id>>).value!.map((id) => question.getChoice(id)!.label),
        ...multipleAnswerArgs
      });
    // Otherwise the question is of a simple type
    const { type } = question;
    // `getAnswer()` ensures that the answer value is not missing and of the correct type
    const { value } = answer;
    switch (type) {
      case QUESTION_TYPE.Boolean:
        return this.formatters.booleanAnswer({ locale, question, value: value as boolean });
      case QUESTION_TYPE.Date:
        return this.formatters.dateAnswer({ locale, question, value: value as Date });
      case QUESTION_TYPE.Image:
        return this.formatters.imageAnswer({ locale, question, value: value as Image });
      case QUESTION_TYPE.Number:
        return this.formatters.numberAnswer({ locale, question, value: value as number });
      case QUESTION_TYPE.MultipleText:
        return this.formatters.multipleTextAnswer({
          locale,
          question,
          value: value as Array<string>,
          ...multipleAnswerArgs
        });
      case QUESTION_TYPE.Text:
        return this.formatters.textAnswer({ locale, question, value: value as string });
      default:
        throw new DataTypeError(`Unsupported question type: ${type}`);
    }
  }

  /**
   * Set the data formatter for string output.
   * @param type - The type of data to format.
   * @param formatter - The new formatter function.
   */
  setFormatter<TType extends keyof RootFormatters>(type: TType, formatter: RootFormatters[TType]): void {
    this.update(() => (this.formatters[type] = formatter));
  }
}
